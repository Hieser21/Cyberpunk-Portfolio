{"ast":null,"code":"import React, { useRef, useEffect } from 'react';\nimport { animate } from 'motion';\nimport { cx } from '@arwes/tools';\nimport { mergeRefs } from '@arwes/react-tools';\nimport { easing } from '@arwes/animated';\nimport { ANIMATOR_STATES } from '@arwes/animator';\nimport { useAnimator } from '@arwes/react-animator';\nconst {\n  entering,\n  entered,\n  exiting,\n  exited\n} = ANIMATOR_STATES;\nconst minmaxOverflow01 = value => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));\nconst defaultProps = {\n  padding: 50,\n  xOffset: [0, 0],\n  yOffset: [-10, -100],\n  radiusInitial: 4,\n  radiusOffset: [4, 40],\n  sets: 5\n};\nconst Puffs = props => {\n  const propsFull = {\n    ...defaultProps,\n    ...props\n  };\n  const {\n    elementRef: elementRefExternal,\n    className,\n    style\n  } = propsFull;\n  const animator = useAnimator();\n  const elementRef = useRef(null);\n  const propsFullRef = useRef(propsFull);\n  propsFullRef.current = propsFull;\n  useEffect(() => {\n    if (!animator) {\n      return;\n    }\n    const canvas = elementRef.current;\n    const ctx = canvas.getContext('2d');\n    let canvasControl;\n    let puffsControl;\n    let puffsEmptyTimeoutId;\n    const cancelAnimationSubscriptions = () => {\n      canvasControl === null || canvasControl === void 0 ? void 0 : canvasControl.cancel();\n      puffsControl === null || puffsControl === void 0 ? void 0 : puffsControl.cancel();\n      window.clearTimeout(puffsEmptyTimeoutId);\n    };\n    const animatorSubscription = node => {\n      const state = node.state;\n      const {\n        duration\n      } = node.control.getSettings();\n      switch (state) {\n        case entering:\n          {\n            cancelAnimationSubscriptions();\n            const {\n              color,\n              quantity,\n              padding,\n              xOffset,\n              yOffset,\n              radiusInitial,\n              radiusOffset,\n              sets\n            } = propsFullRef.current;\n            const puffsSetQuantity = Math.round(quantity / sets);\n            const puffsSetOffset = 1 / sets;\n            const createPuff = (width, height) => {\n              const x = padding + Math.random() * (width - padding * 2);\n              const y = padding + Math.random() * (height - padding * 2);\n              const r = radiusInitial;\n              const xo = xOffset[0] + Math.random() * xOffset[1];\n              const yo = yOffset[0] + Math.random() * yOffset[1];\n              const ro = radiusOffset[0] + Math.random() * radiusOffset[1];\n              return {\n                x,\n                y,\n                r,\n                xo,\n                yo,\n                ro\n              };\n            };\n            const createPuffsSets = (width, height) => {\n              return Array(sets).fill(null).map(() => Array(puffsSetQuantity).fill(null).map(() => createPuff(width, height)));\n            };\n            const drawPuffs = (puffs, progress) => {\n              // From: 0 at 0%, 1 at 50%, 0 at 100%.\n              ctx.globalAlpha = progress <= 0.5 ? progress * 2 : -2 * progress + 2;\n              puffs.forEach(puff => {\n                const x = puff.x + progress * puff.xo;\n                const y = puff.y + progress * puff.yo;\n                const r = puff.r + progress * puff.ro;\n                const grd = ctx.createRadialGradient(x, y, 0, x, y, r);\n                grd.addColorStop(0, color);\n                grd.addColorStop(1, 'transparent');\n                ctx.beginPath();\n                ctx.fillStyle = grd;\n                ctx.arc(x, y, r, 0, 2 * Math.PI);\n                ctx.fill();\n                ctx.closePath();\n              });\n            };\n            let puffsSets = [];\n            const draw = intervalProgress => {\n              const width = canvas.clientWidth;\n              const height = canvas.clientHeight;\n              const isResized = canvas.width !== width || canvas.height !== height;\n              if (isResized || !puffsSets.length) {\n                puffsSets = createPuffsSets(width, height);\n              }\n              canvas.width = width;\n              canvas.height = height;\n              ctx.clearRect(0, 0, width, height);\n              puffsSets.forEach((puffs, index) => {\n                const puffsOffset = puffsSetOffset * index;\n                const puffsProgress = minmaxOverflow01(intervalProgress + puffsOffset);\n                drawPuffs(puffs, easing.outSine(puffsProgress));\n              });\n            };\n            canvasControl = animate(canvas, {\n              opacity: [0, 1]\n            }, {\n              duration: duration === null || duration === void 0 ? void 0 : duration.enter\n            });\n            const runPuffsAnimation = () => {\n              puffsControl = animate(progress => {\n                draw(progress);\n                if (progress >= 1) {\n                  const emptyDuration = ((duration === null || duration === void 0 ? void 0 : duration.intervalPause) || 0) * 1000;\n                  window.clearTimeout(puffsEmptyTimeoutId);\n                  window.setTimeout(runPuffsAnimation, emptyDuration);\n                }\n              }, {\n                duration: duration === null || duration === void 0 ? void 0 : duration.interval,\n                easing: 'linear'\n              });\n            };\n            runPuffsAnimation();\n            break;\n          }\n        case entered:\n          {\n            break;\n          }\n        case exiting:\n          {\n            canvasControl === null || canvasControl === void 0 ? void 0 : canvasControl.cancel();\n            canvasControl = animate(canvas, {\n              opacity: [1, 0]\n            }, {\n              duration: duration === null || duration === void 0 ? void 0 : duration.exit\n            });\n            break;\n          }\n        case exited:\n          {\n            cancelAnimationSubscriptions();\n            canvas.style.opacity = '0';\n            break;\n          }\n      }\n    };\n    animator.node.subscribers.add(animatorSubscription);\n    return () => {\n      animator.node.subscribers.delete(animatorSubscription);\n      cancelAnimationSubscriptions();\n    };\n  }, [animator]);\n  return React.createElement(\"canvas\", {\n    ref: mergeRefs(elementRef, elementRefExternal),\n    className: cx('arwes-react-bgs-puffs', className),\n    style: {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      display: 'block',\n      border: 0,\n      margin: 0,\n      padding: 0,\n      width: '100%',\n      height: '100%',\n      ...style\n    }\n  });\n};\nPuffs.defaultProps = defaultProps;\nexport { Puffs };","map":{"version":3,"names":["React","useRef","useEffect","animate","cx","mergeRefs","easing","ANIMATOR_STATES","useAnimator","entering","entered","exiting","exited","minmaxOverflow01","value","Math","min","max","defaultProps","padding","xOffset","yOffset","radiusInitial","radiusOffset","sets","Puffs","props","propsFull","elementRef","elementRefExternal","className","style","animator","propsFullRef","current","canvas","ctx","getContext","canvasControl","puffsControl","puffsEmptyTimeoutId","cancelAnimationSubscriptions","cancel","window","clearTimeout","animatorSubscription","node","state","duration","control","getSettings","color","quantity","puffsSetQuantity","round","puffsSetOffset","createPuff","width","height","x","random","y","r","xo","yo","ro","createPuffsSets","Array","fill","map","drawPuffs","puffs","progress","globalAlpha","forEach","puff","grd","createRadialGradient","addColorStop","beginPath","fillStyle","arc","PI","closePath","puffsSets","draw","intervalProgress","clientWidth","clientHeight","isResized","length","clearRect","index","puffsOffset","puffsProgress","outSine","opacity","enter","runPuffsAnimation","emptyDuration","intervalPause","setTimeout","interval","exit","subscribers","add","delete","createElement","ref","position","left","top","display","border","margin"],"sources":["/Users/richardbrown/Desktop/react example/my-app/node_modules/@arwes/react-bgs/build/esm/Puffs/Puffs.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { animate } from 'motion';\nimport { cx } from '@arwes/tools';\nimport { mergeRefs } from '@arwes/react-tools';\nimport { easing } from '@arwes/animated';\nimport { ANIMATOR_STATES } from '@arwes/animator';\nimport { useAnimator } from '@arwes/react-animator';\nconst { entering, entered, exiting, exited } = ANIMATOR_STATES;\nconst minmaxOverflow01 = (value) => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));\nconst defaultProps = {\n    padding: 50,\n    xOffset: [0, 0],\n    yOffset: [-10, -100],\n    radiusInitial: 4,\n    radiusOffset: [4, 40],\n    sets: 5\n};\nconst Puffs = (props) => {\n    const propsFull = { ...defaultProps, ...props };\n    const { elementRef: elementRefExternal, className, style } = propsFull;\n    const animator = useAnimator();\n    const elementRef = useRef(null);\n    const propsFullRef = useRef(propsFull);\n    propsFullRef.current = propsFull;\n    useEffect(() => {\n        if (!animator) {\n            return;\n        }\n        const canvas = elementRef.current;\n        const ctx = canvas.getContext('2d');\n        let canvasControl;\n        let puffsControl;\n        let puffsEmptyTimeoutId;\n        const cancelAnimationSubscriptions = () => {\n            canvasControl === null || canvasControl === void 0 ? void 0 : canvasControl.cancel();\n            puffsControl === null || puffsControl === void 0 ? void 0 : puffsControl.cancel();\n            window.clearTimeout(puffsEmptyTimeoutId);\n        };\n        const animatorSubscription = (node) => {\n            const state = node.state;\n            const { duration } = node.control.getSettings();\n            switch (state) {\n                case entering: {\n                    cancelAnimationSubscriptions();\n                    const { color, quantity, padding, xOffset, yOffset, radiusInitial, radiusOffset, sets } = propsFullRef.current;\n                    const puffsSetQuantity = Math.round(quantity / sets);\n                    const puffsSetOffset = 1 / sets;\n                    const createPuff = (width, height) => {\n                        const x = padding + (Math.random() * (width - (padding * 2)));\n                        const y = padding + (Math.random() * (height - (padding * 2)));\n                        const r = radiusInitial;\n                        const xo = xOffset[0] + (Math.random() * xOffset[1]);\n                        const yo = yOffset[0] + (Math.random() * yOffset[1]);\n                        const ro = radiusOffset[0] + (Math.random() * radiusOffset[1]);\n                        return { x, y, r, xo, yo, ro };\n                    };\n                    const createPuffsSets = (width, height) => {\n                        return Array(sets)\n                            .fill(null)\n                            .map(() => Array(puffsSetQuantity)\n                            .fill(null)\n                            .map(() => createPuff(width, height)));\n                    };\n                    const drawPuffs = (puffs, progress) => {\n                        // From: 0 at 0%, 1 at 50%, 0 at 100%.\n                        ctx.globalAlpha = progress <= 0.5\n                            ? progress * 2\n                            : -2 * progress + 2;\n                        puffs.forEach(puff => {\n                            const x = puff.x + (progress * puff.xo);\n                            const y = puff.y + (progress * puff.yo);\n                            const r = puff.r + (progress * puff.ro);\n                            const grd = ctx.createRadialGradient(x, y, 0, x, y, r);\n                            grd.addColorStop(0, color);\n                            grd.addColorStop(1, 'transparent');\n                            ctx.beginPath();\n                            ctx.fillStyle = grd;\n                            ctx.arc(x, y, r, 0, 2 * Math.PI);\n                            ctx.fill();\n                            ctx.closePath();\n                        });\n                    };\n                    let puffsSets = [];\n                    const draw = (intervalProgress) => {\n                        const width = canvas.clientWidth;\n                        const height = canvas.clientHeight;\n                        const isResized = canvas.width !== width || canvas.height !== height;\n                        if (isResized || !puffsSets.length) {\n                            puffsSets = createPuffsSets(width, height);\n                        }\n                        canvas.width = width;\n                        canvas.height = height;\n                        ctx.clearRect(0, 0, width, height);\n                        puffsSets.forEach((puffs, index) => {\n                            const puffsOffset = puffsSetOffset * index;\n                            const puffsProgress = minmaxOverflow01(intervalProgress + puffsOffset);\n                            drawPuffs(puffs, easing.outSine(puffsProgress));\n                        });\n                    };\n                    canvasControl = animate(canvas, { opacity: [0, 1] }, { duration: duration === null || duration === void 0 ? void 0 : duration.enter });\n                    const runPuffsAnimation = () => {\n                        puffsControl = animate((progress) => {\n                            draw(progress);\n                            if (progress >= 1) {\n                                const emptyDuration = ((duration === null || duration === void 0 ? void 0 : duration.intervalPause) || 0) * 1000;\n                                window.clearTimeout(puffsEmptyTimeoutId);\n                                window.setTimeout(runPuffsAnimation, emptyDuration);\n                            }\n                        }, { duration: duration === null || duration === void 0 ? void 0 : duration.interval, easing: 'linear' });\n                    };\n                    runPuffsAnimation();\n                    break;\n                }\n                case entered: {\n                    break;\n                }\n                case exiting: {\n                    canvasControl === null || canvasControl === void 0 ? void 0 : canvasControl.cancel();\n                    canvasControl = animate(canvas, { opacity: [1, 0] }, { duration: duration === null || duration === void 0 ? void 0 : duration.exit });\n                    break;\n                }\n                case exited: {\n                    cancelAnimationSubscriptions();\n                    canvas.style.opacity = '0';\n                    break;\n                }\n            }\n        };\n        animator.node.subscribers.add(animatorSubscription);\n        return () => {\n            animator.node.subscribers.delete(animatorSubscription);\n            cancelAnimationSubscriptions();\n        };\n    }, [animator]);\n    return (React.createElement(\"canvas\", { ref: mergeRefs(elementRef, elementRefExternal), className: cx('arwes-react-bgs-puffs', className), style: {\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            display: 'block',\n            border: 0,\n            margin: 0,\n            padding: 0,\n            width: '100%',\n            height: '100%',\n            ...style\n        } }));\n};\nPuffs.defaultProps = defaultProps;\nexport { Puffs };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}