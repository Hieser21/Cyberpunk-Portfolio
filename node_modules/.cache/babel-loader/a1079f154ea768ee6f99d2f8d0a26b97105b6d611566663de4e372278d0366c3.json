{"ast":null,"code":"import React, { useRef, useEffect } from 'react';\nimport { animate } from 'motion';\nimport { cx } from '@arwes/tools';\nimport { mergeRefs } from '@arwes/react-tools';\nimport { ANIMATOR_STATES } from '@arwes/animator';\nimport { useAnimator } from '@arwes/react-animator';\nimport { getDistanceFromOriginToCornerProgress } from \"./getDistanceFromOriginToCornerProgress.js\";\nconst {\n  entering,\n  exiting\n} = ANIMATOR_STATES;\nconst defaultProps = {\n  color: '#777',\n  type: 'box',\n  distance: 30,\n  size: 4,\n  origin: 'center'\n};\nconst Dots = props => {\n  const propsFull = {\n    ...defaultProps,\n    ...props\n  };\n  const {\n    elementRef: elementRefExternal,\n    className,\n    style\n  } = propsFull;\n  const animator = useAnimator();\n  const elementRef = useRef(null);\n  const propsFullRef = useRef(propsFull);\n  propsFullRef.current = propsFull;\n  useEffect(() => {\n    if (!animator) {\n      return;\n    }\n    let animationControl;\n    let resizeObserver;\n    const cancelAnimationSubscriptions = () => {\n      animationControl === null || animationControl === void 0 ? void 0 : animationControl.cancel();\n      resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();\n    };\n    const animatorSubscription = node => {\n      if (node.state !== entering && node.state !== exiting) {\n        return;\n      }\n      cancelAnimationSubscriptions();\n      const active = node.state === entering;\n      const {\n        duration\n      } = node.control.getSettings();\n      const transitionDuration = (active ? duration === null || duration === void 0 ? void 0 : duration.enter : duration === null || duration === void 0 ? void 0 : duration.exit) || 0;\n      const canvas = elementRef.current;\n      const ctx = canvas.getContext('2d');\n      const draw = progress => {\n        const {\n          color,\n          type,\n          distance,\n          size,\n          origin,\n          originInverted\n        } = propsFullRef.current;\n        const width = canvas.clientWidth;\n        const height = canvas.clientHeight;\n        const xLength = 1 + Math.floor(width / distance);\n        const yLength = 1 + Math.floor(height / distance);\n        const xMargin = width % distance;\n        const yMargin = height % distance;\n        // Only assign size if they changed.\n        if (canvas.width !== width || canvas.height !== height) {\n          canvas.width = width;\n          canvas.height = height;\n        }\n        ctx.clearRect(0, 0, width, height);\n        for (let xIndex = 0; xIndex < xLength; xIndex++) {\n          const x = xMargin / 2 + xIndex * distance;\n          for (let yIndex = 0; yIndex < yLength; yIndex++) {\n            const y = yMargin / 2 + yIndex * distance;\n            const distanceFromOriginProgress = getDistanceFromOriginToCornerProgress(width, height, x, y, origin);\n            const distancePercentage = active && originInverted || !active && !originInverted ? 1 - distanceFromOriginProgress : distanceFromOriginProgress;\n            const alphaProgress = progress / distancePercentage;\n            const alpha = Math.max(0, Math.min(1, alphaProgress));\n            ctx.beginPath();\n            ctx.globalAlpha = active ? alpha : 1 - alpha;\n            if (type === 'box') {\n              ctx.rect(x - size / 2, y - size / 2, size, size);\n            } else {\n              ctx.arc(x, y, size, 0, 2 * Math.PI);\n            }\n            ctx.fillStyle = color;\n            ctx.fill();\n            ctx.closePath();\n          }\n        }\n      };\n      animationControl = animate(draw, {\n        duration: transitionDuration,\n        easing: 'ease-in-out'\n      });\n      if (window.ResizeObserver) {\n        resizeObserver = new window.ResizeObserver(() => {\n          const currentTime = (animationControl === null || animationControl === void 0 ? void 0 : animationControl.currentTime) || 0;\n          if (active && currentTime >= transitionDuration) {\n            draw(1);\n          }\n        });\n        resizeObserver.observe(canvas);\n      }\n    };\n    animator.node.subscribers.add(animatorSubscription);\n    return () => {\n      animator.node.subscribers.delete(animatorSubscription);\n      cancelAnimationSubscriptions();\n    };\n  }, [animator]);\n  return React.createElement(\"canvas\", {\n    ref: mergeRefs(elementRef, elementRefExternal),\n    className: cx('arwes-react-bgs-dots', className),\n    style: {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      display: 'block',\n      border: 0,\n      margin: 0,\n      padding: 0,\n      width: '100%',\n      height: '100%',\n      ...style\n    }\n  });\n};\nDots.defaultProps = defaultProps;\nexport { Dots };","map":{"version":3,"names":["React","useRef","useEffect","animate","cx","mergeRefs","ANIMATOR_STATES","useAnimator","getDistanceFromOriginToCornerProgress","entering","exiting","defaultProps","color","type","distance","size","origin","Dots","props","propsFull","elementRef","elementRefExternal","className","style","animator","propsFullRef","current","animationControl","resizeObserver","cancelAnimationSubscriptions","cancel","disconnect","animatorSubscription","node","state","active","duration","control","getSettings","transitionDuration","enter","exit","canvas","ctx","getContext","draw","progress","originInverted","width","clientWidth","height","clientHeight","xLength","Math","floor","yLength","xMargin","yMargin","clearRect","xIndex","x","yIndex","y","distanceFromOriginProgress","distancePercentage","alphaProgress","alpha","max","min","beginPath","globalAlpha","rect","arc","PI","fillStyle","fill","closePath","easing","window","ResizeObserver","currentTime","observe","subscribers","add","delete","createElement","ref","position","left","top","display","border","margin","padding"],"sources":["/Users/richardbrown/Desktop/react example/my-app/node_modules/@arwes/react-bgs/build/esm/Dots/Dots.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { animate } from 'motion';\nimport { cx } from '@arwes/tools';\nimport { mergeRefs } from '@arwes/react-tools';\nimport { ANIMATOR_STATES } from '@arwes/animator';\nimport { useAnimator } from '@arwes/react-animator';\nimport { getDistanceFromOriginToCornerProgress } from \"./getDistanceFromOriginToCornerProgress.js\";\nconst { entering, exiting } = ANIMATOR_STATES;\nconst defaultProps = {\n    color: '#777',\n    type: 'box',\n    distance: 30,\n    size: 4,\n    origin: 'center'\n};\nconst Dots = (props) => {\n    const propsFull = { ...defaultProps, ...props };\n    const { elementRef: elementRefExternal, className, style } = propsFull;\n    const animator = useAnimator();\n    const elementRef = useRef(null);\n    const propsFullRef = useRef(propsFull);\n    propsFullRef.current = propsFull;\n    useEffect(() => {\n        if (!animator) {\n            return;\n        }\n        let animationControl;\n        let resizeObserver;\n        const cancelAnimationSubscriptions = () => {\n            animationControl === null || animationControl === void 0 ? void 0 : animationControl.cancel();\n            resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();\n        };\n        const animatorSubscription = (node) => {\n            if (node.state !== entering && node.state !== exiting) {\n                return;\n            }\n            cancelAnimationSubscriptions();\n            const active = node.state === entering;\n            const { duration } = node.control.getSettings();\n            const transitionDuration = (active ? duration === null || duration === void 0 ? void 0 : duration.enter : duration === null || duration === void 0 ? void 0 : duration.exit) || 0;\n            const canvas = elementRef.current;\n            const ctx = canvas.getContext('2d');\n            const draw = (progress) => {\n                const { color, type, distance, size, origin, originInverted } = propsFullRef.current;\n                const width = canvas.clientWidth;\n                const height = canvas.clientHeight;\n                const xLength = 1 + Math.floor(width / distance);\n                const yLength = 1 + Math.floor(height / distance);\n                const xMargin = width % distance;\n                const yMargin = height % distance;\n                // Only assign size if they changed.\n                if (canvas.width !== width || canvas.height !== height) {\n                    canvas.width = width;\n                    canvas.height = height;\n                }\n                ctx.clearRect(0, 0, width, height);\n                for (let xIndex = 0; xIndex < xLength; xIndex++) {\n                    const x = (xMargin / 2) + (xIndex * distance);\n                    for (let yIndex = 0; yIndex < yLength; yIndex++) {\n                        const y = (yMargin / 2) + (yIndex * distance);\n                        const distanceFromOriginProgress = getDistanceFromOriginToCornerProgress(width, height, x, y, origin);\n                        const distancePercentage = (active && originInverted) || (!active && !originInverted)\n                            ? 1 - distanceFromOriginProgress\n                            : distanceFromOriginProgress;\n                        const alphaProgress = progress / distancePercentage;\n                        const alpha = Math.max(0, Math.min(1, alphaProgress));\n                        ctx.beginPath();\n                        ctx.globalAlpha = active ? alpha : 1 - alpha;\n                        if (type === 'box') {\n                            ctx.rect(x - (size / 2), y - (size / 2), size, size);\n                        }\n                        else {\n                            ctx.arc(x, y, size, 0, 2 * Math.PI);\n                        }\n                        ctx.fillStyle = color;\n                        ctx.fill();\n                        ctx.closePath();\n                    }\n                }\n            };\n            animationControl = animate(draw, {\n                duration: transitionDuration,\n                easing: 'ease-in-out'\n            });\n            if (window.ResizeObserver) {\n                resizeObserver = new window.ResizeObserver(() => {\n                    const currentTime = (animationControl === null || animationControl === void 0 ? void 0 : animationControl.currentTime) || 0;\n                    if (active && currentTime >= transitionDuration) {\n                        draw(1);\n                    }\n                });\n                resizeObserver.observe(canvas);\n            }\n        };\n        animator.node.subscribers.add(animatorSubscription);\n        return () => {\n            animator.node.subscribers.delete(animatorSubscription);\n            cancelAnimationSubscriptions();\n        };\n    }, [animator]);\n    return (React.createElement(\"canvas\", { ref: mergeRefs(elementRef, elementRefExternal), className: cx('arwes-react-bgs-dots', className), style: {\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            display: 'block',\n            border: 0,\n            margin: 0,\n            padding: 0,\n            width: '100%',\n            height: '100%',\n            ...style\n        } }));\n};\nDots.defaultProps = defaultProps;\nexport { Dots };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}