{"ast":null,"code":"import { ANIMATOR_MANAGER_NAMES as MANAGERS, ANIMATOR_ACTIONS as ACTIONS, ANIMATOR_STATES as STATES } from \"../../constants.js\";\nconst createAnimatorManagerParallel = node => {\n  const getChildren = childrenProvided => {\n    const children = childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children);\n    return children.filter(child => {\n      const {\n        condition\n      } = child.control.getSettings();\n      return condition ? condition(child) : true;\n    });\n  };\n  const getDurationEnter = childrenProvided => {\n    const children = getChildren(childrenProvided);\n    return children.reduce((total, child) => Math.max(total, child.duration.enter), 0);\n  };\n  const enterChildren = childrenProvided => {\n    const children = getChildren(childrenProvided);\n    for (const child of children) {\n      child.send(ACTIONS.enter);\n    }\n  };\n  return Object.freeze({\n    name: MANAGERS.parallel,\n    getDurationEnter,\n    enterChildren\n  });\n};\nconst createAnimatorManagerStagger = (node, name) => {\n  let reservedUntilTime = 0;\n  const getChildren = childrenProvided => {\n    const children = childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children);\n    return children.filter(child => {\n      const {\n        condition\n      } = child.control.getSettings();\n      return condition ? condition(child) : true;\n    });\n  };\n  const getDurationEnter = childrenProvided => {\n    const children = getChildren(childrenProvided);\n    if (!children.length) {\n      return 0;\n    }\n    const {\n      duration\n    } = node.control.getSettings();\n    const lastChild = children[children.length - 1];\n    // TODO: If any of the children has a longer enter duration which surpasses\n    // the accumulated + last child enter duration value, the total duration should\n    // be greater.\n    return duration.stagger * (children.length - 1) + lastChild.duration.enter;\n  };\n  const enterChildren = childrenProvided => {\n    let children = getChildren(childrenProvided);\n    const parentSettings = node.control.getSettings();\n    const stagger = (parentSettings.duration.stagger || 0) * 1000; // seconds to ms\n    if (name === MANAGERS.staggerReverse) {\n      children = children.reverse();\n    }\n    const now = Date.now();\n    reservedUntilTime = Math.max(reservedUntilTime, now);\n    for (const child of children) {\n      const childSettings = child.control.getSettings();\n      const offset = (childSettings.duration.offset || 0) * 1000; // seconds to ms\n      reservedUntilTime = reservedUntilTime + offset;\n      const time = (reservedUntilTime - now) / 1000; // ms to seconds\n      const delay = childSettings.duration.delay || 0;\n      reservedUntilTime = reservedUntilTime + stagger;\n      child.scheduler.start(time + delay, () => child.send(ACTIONS.enter));\n    }\n  };\n  return Object.freeze({\n    name,\n    getDurationEnter,\n    enterChildren\n  });\n};\nconst createAnimatorManagerSequence = (node, name) => {\n  let reservedUntilTime = 0;\n  const getChildren = childrenProvided => {\n    const children = childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children);\n    return children.filter(child => {\n      const {\n        condition\n      } = child.control.getSettings();\n      return condition ? condition(child) : true;\n    });\n  };\n  const getDurationEnter = childrenProvided => {\n    const children = getChildren(childrenProvided);\n    return children.reduce((total, child) => total + child.duration.enter, 0);\n  };\n  const enterChildren = childrenProvided => {\n    let children = getChildren(childrenProvided);\n    const now = Date.now();\n    if (name === MANAGERS.sequenceReverse) {\n      children = children.reverse();\n    }\n    reservedUntilTime = Math.max(reservedUntilTime, now);\n    for (const child of children) {\n      const childSettings = child.control.getSettings();\n      const offset = (childSettings.duration.offset || 0) * 1000; // seconds to ms\n      const durationEnter = child.duration.enter * 1000; // seconds to ms\n      reservedUntilTime = reservedUntilTime + offset;\n      const time = (reservedUntilTime - now) / 1000; // ms to seconds\n      const delay = childSettings.duration.delay || 0;\n      reservedUntilTime += durationEnter;\n      child.scheduler.start(time + delay, () => child.send(ACTIONS.enter));\n    }\n  };\n  return Object.freeze({\n    name,\n    getDurationEnter,\n    enterChildren\n  });\n};\nconst createAnimatorManagerSwitch = node => {\n  let nodeHiding;\n  let nodeVisible;\n  let nodeSubscriberUnsubscribe;\n  const getDurationEnter = () => {\n    if (nodeVisible) {\n      return nodeVisible.duration.enter;\n    }\n    const nodeVisibleCurrent = Array.from(node.children).find(child => {\n      const {\n        condition\n      } = child.control.getSettings();\n      return condition ? condition(child) : true;\n    });\n    if (nodeVisibleCurrent) {\n      return nodeVisibleCurrent.duration.enter;\n    }\n    return 0;\n  };\n  const enterChildren = () => {\n    nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();\n    nodeSubscriberUnsubscribe = undefined;\n    const children = Array.from(node.children);\n    const nodeVisibleNew = children.find(child => {\n      const {\n        condition\n      } = child.control.getSettings();\n      return condition ? condition(child) : true;\n    });\n    const onNextEnter = () => {\n      if (nodeVisibleNew) {\n        if (nodeVisibleNew === nodeVisible) {\n          nodeVisibleNew.send(ACTIONS.enter);\n        } else {\n          if (nodeVisible) {\n            nodeHiding = nodeVisible;\n            nodeSubscriberUnsubscribe = nodeHiding.subscribe(nodeHidingSubscribed => {\n              if (nodeHidingSubscribed.state === STATES.exited) {\n                nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();\n                nodeSubscriberUnsubscribe = undefined;\n                nodeHiding = undefined;\n                nodeVisibleNew.send(ACTIONS.enter);\n              }\n            });\n            nodeHiding === null || nodeHiding === void 0 ? void 0 : nodeHiding.send(ACTIONS.exit);\n          } else {\n            nodeVisibleNew.send(ACTIONS.enter);\n            nodeHiding = undefined;\n          }\n          nodeVisible = nodeVisibleNew;\n        }\n      } else {\n        nodeHiding = nodeVisible;\n        nodeVisible = undefined;\n      }\n    };\n    if (nodeHiding) {\n      nodeSubscriberUnsubscribe = nodeHiding.subscribe(nodeHiding => {\n        if (nodeHiding.state === STATES.exited) {\n          onNextEnter();\n        }\n      });\n    } else {\n      onNextEnter();\n    }\n    children.filter(child => child !== nodeVisibleNew).forEach(child => child.send(ACTIONS.exit));\n  };\n  const destroy = () => {\n    nodeHiding = undefined;\n    nodeVisible = undefined;\n    nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();\n    nodeSubscriberUnsubscribe = undefined;\n  };\n  return Object.freeze({\n    name: MANAGERS.switch,\n    getDurationEnter,\n    enterChildren,\n    destroy\n  });\n};\nconst createAnimatorManager = (node, manager) => {\n  switch (manager) {\n    case MANAGERS.stagger:\n      return createAnimatorManagerStagger(node, MANAGERS.stagger);\n    case MANAGERS.staggerReverse:\n      return createAnimatorManagerStagger(node, MANAGERS.staggerReverse);\n    case MANAGERS.sequence:\n      return createAnimatorManagerSequence(node, MANAGERS.sequence);\n    case MANAGERS.sequenceReverse:\n      return createAnimatorManagerSequence(node, MANAGERS.sequenceReverse);\n    case MANAGERS.switch:\n      return createAnimatorManagerSwitch(node, MANAGERS.switch);\n    default:\n      return createAnimatorManagerParallel(node, MANAGERS.parallel);\n  }\n};\nexport { createAnimatorManager };","map":{"version":3,"names":["ANIMATOR_MANAGER_NAMES","MANAGERS","ANIMATOR_ACTIONS","ACTIONS","ANIMATOR_STATES","STATES","createAnimatorManagerParallel","node","getChildren","childrenProvided","children","Array","from","filter","child","condition","control","getSettings","getDurationEnter","reduce","total","Math","max","duration","enter","enterChildren","send","Object","freeze","name","parallel","createAnimatorManagerStagger","reservedUntilTime","length","lastChild","stagger","parentSettings","staggerReverse","reverse","now","Date","childSettings","offset","time","delay","scheduler","start","createAnimatorManagerSequence","sequenceReverse","durationEnter","createAnimatorManagerSwitch","nodeHiding","nodeVisible","nodeSubscriberUnsubscribe","nodeVisibleCurrent","find","undefined","nodeVisibleNew","onNextEnter","subscribe","nodeHidingSubscribed","state","exited","exit","forEach","destroy","switch","createAnimatorManager","manager","sequence"],"sources":["/Users/richardbrown/Desktop/react example/my-app/node_modules/@arwes/animator/build/esm/internal/createAnimatorManager/createAnimatorManager.js"],"sourcesContent":["import { ANIMATOR_MANAGER_NAMES as MANAGERS, ANIMATOR_ACTIONS as ACTIONS, ANIMATOR_STATES as STATES } from \"../../constants.js\";\nconst createAnimatorManagerParallel = node => {\n    const getChildren = (childrenProvided) => {\n        const children = (childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children));\n        return children.filter(child => {\n            const { condition } = child.control.getSettings();\n            return condition ? condition(child) : true;\n        });\n    };\n    const getDurationEnter = (childrenProvided) => {\n        const children = getChildren(childrenProvided);\n        return children.reduce((total, child) => Math.max(total, child.duration.enter), 0);\n    };\n    const enterChildren = (childrenProvided) => {\n        const children = getChildren(childrenProvided);\n        for (const child of children) {\n            child.send(ACTIONS.enter);\n        }\n    };\n    return Object.freeze({\n        name: MANAGERS.parallel,\n        getDurationEnter,\n        enterChildren\n    });\n};\nconst createAnimatorManagerStagger = (node, name) => {\n    let reservedUntilTime = 0;\n    const getChildren = (childrenProvided) => {\n        const children = (childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children));\n        return children.filter(child => {\n            const { condition } = child.control.getSettings();\n            return condition ? condition(child) : true;\n        });\n    };\n    const getDurationEnter = (childrenProvided) => {\n        const children = getChildren(childrenProvided);\n        if (!children.length) {\n            return 0;\n        }\n        const { duration } = node.control.getSettings();\n        const lastChild = children[children.length - 1];\n        // TODO: If any of the children has a longer enter duration which surpasses\n        // the accumulated + last child enter duration value, the total duration should\n        // be greater.\n        return (duration.stagger * (children.length - 1)) + lastChild.duration.enter;\n    };\n    const enterChildren = (childrenProvided) => {\n        let children = getChildren(childrenProvided);\n        const parentSettings = node.control.getSettings();\n        const stagger = (parentSettings.duration.stagger || 0) * 1000; // seconds to ms\n        if (name === MANAGERS.staggerReverse) {\n            children = children.reverse();\n        }\n        const now = Date.now();\n        reservedUntilTime = Math.max(reservedUntilTime, now);\n        for (const child of children) {\n            const childSettings = child.control.getSettings();\n            const offset = (childSettings.duration.offset || 0) * 1000; // seconds to ms\n            reservedUntilTime = reservedUntilTime + offset;\n            const time = (reservedUntilTime - now) / 1000; // ms to seconds\n            const delay = childSettings.duration.delay || 0;\n            reservedUntilTime = reservedUntilTime + stagger;\n            child.scheduler.start(time + delay, () => child.send(ACTIONS.enter));\n        }\n    };\n    return Object.freeze({\n        name,\n        getDurationEnter,\n        enterChildren\n    });\n};\nconst createAnimatorManagerSequence = (node, name) => {\n    let reservedUntilTime = 0;\n    const getChildren = (childrenProvided) => {\n        const children = (childrenProvided !== null && childrenProvided !== void 0 ? childrenProvided : Array.from(node.children));\n        return children.filter(child => {\n            const { condition } = child.control.getSettings();\n            return condition ? condition(child) : true;\n        });\n    };\n    const getDurationEnter = (childrenProvided) => {\n        const children = getChildren(childrenProvided);\n        return children.reduce((total, child) => total + child.duration.enter, 0);\n    };\n    const enterChildren = (childrenProvided) => {\n        let children = getChildren(childrenProvided);\n        const now = Date.now();\n        if (name === MANAGERS.sequenceReverse) {\n            children = children.reverse();\n        }\n        reservedUntilTime = Math.max(reservedUntilTime, now);\n        for (const child of children) {\n            const childSettings = child.control.getSettings();\n            const offset = (childSettings.duration.offset || 0) * 1000; // seconds to ms\n            const durationEnter = child.duration.enter * 1000; // seconds to ms\n            reservedUntilTime = reservedUntilTime + offset;\n            const time = (reservedUntilTime - now) / 1000; // ms to seconds\n            const delay = childSettings.duration.delay || 0;\n            reservedUntilTime += durationEnter;\n            child.scheduler.start(time + delay, () => child.send(ACTIONS.enter));\n        }\n    };\n    return Object.freeze({\n        name,\n        getDurationEnter,\n        enterChildren\n    });\n};\nconst createAnimatorManagerSwitch = node => {\n    let nodeHiding;\n    let nodeVisible;\n    let nodeSubscriberUnsubscribe;\n    const getDurationEnter = () => {\n        if (nodeVisible) {\n            return nodeVisible.duration.enter;\n        }\n        const nodeVisibleCurrent = Array.from(node.children).find(child => {\n            const { condition } = child.control.getSettings();\n            return condition ? condition(child) : true;\n        });\n        if (nodeVisibleCurrent) {\n            return nodeVisibleCurrent.duration.enter;\n        }\n        return 0;\n    };\n    const enterChildren = () => {\n        nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();\n        nodeSubscriberUnsubscribe = undefined;\n        const children = Array.from(node.children);\n        const nodeVisibleNew = children.find(child => {\n            const { condition } = child.control.getSettings();\n            return condition ? condition(child) : true;\n        });\n        const onNextEnter = () => {\n            if (nodeVisibleNew) {\n                if (nodeVisibleNew === nodeVisible) {\n                    nodeVisibleNew.send(ACTIONS.enter);\n                }\n                else {\n                    if (nodeVisible) {\n                        nodeHiding = nodeVisible;\n                        nodeSubscriberUnsubscribe = nodeHiding.subscribe(nodeHidingSubscribed => {\n                            if (nodeHidingSubscribed.state === STATES.exited) {\n                                nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();\n                                nodeSubscriberUnsubscribe = undefined;\n                                nodeHiding = undefined;\n                                nodeVisibleNew.send(ACTIONS.enter);\n                            }\n                        });\n                        nodeHiding === null || nodeHiding === void 0 ? void 0 : nodeHiding.send(ACTIONS.exit);\n                    }\n                    else {\n                        nodeVisibleNew.send(ACTIONS.enter);\n                        nodeHiding = undefined;\n                    }\n                    nodeVisible = nodeVisibleNew;\n                }\n            }\n            else {\n                nodeHiding = nodeVisible;\n                nodeVisible = undefined;\n            }\n        };\n        if (nodeHiding) {\n            nodeSubscriberUnsubscribe = nodeHiding.subscribe(nodeHiding => {\n                if (nodeHiding.state === STATES.exited) {\n                    onNextEnter();\n                }\n            });\n        }\n        else {\n            onNextEnter();\n        }\n        children\n            .filter(child => child !== nodeVisibleNew)\n            .forEach(child => child.send(ACTIONS.exit));\n    };\n    const destroy = () => {\n        nodeHiding = undefined;\n        nodeVisible = undefined;\n        nodeSubscriberUnsubscribe === null || nodeSubscriberUnsubscribe === void 0 ? void 0 : nodeSubscriberUnsubscribe();\n        nodeSubscriberUnsubscribe = undefined;\n    };\n    return Object.freeze({\n        name: MANAGERS.switch,\n        getDurationEnter,\n        enterChildren,\n        destroy\n    });\n};\nconst createAnimatorManager = (node, manager) => {\n    switch (manager) {\n        case MANAGERS.stagger: return createAnimatorManagerStagger(node, MANAGERS.stagger);\n        case MANAGERS.staggerReverse: return createAnimatorManagerStagger(node, MANAGERS.staggerReverse);\n        case MANAGERS.sequence: return createAnimatorManagerSequence(node, MANAGERS.sequence);\n        case MANAGERS.sequenceReverse: return createAnimatorManagerSequence(node, MANAGERS.sequenceReverse);\n        case MANAGERS.switch: return createAnimatorManagerSwitch(node, MANAGERS.switch);\n        default: return createAnimatorManagerParallel(node, MANAGERS.parallel);\n    }\n};\nexport { createAnimatorManager };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}