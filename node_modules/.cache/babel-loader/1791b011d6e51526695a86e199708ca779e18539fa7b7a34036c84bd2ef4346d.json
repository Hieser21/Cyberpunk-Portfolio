{"ast":null,"code":"import { IS_BROWSER } from '@arwes/tools';\nimport { ANIMATOR_STATES as STATES, ANIMATOR_ACTIONS as ACTIONS } from \"../../constants.js\";\nimport { createAnimatorManager } from \"../../internal/createAnimatorManager/index.js\";\nconst createAnimatorMachine = (node, initialState) => {\n  let state = initialState;\n  const statesMap = {\n    [STATES.exited]: {\n      onActions: {\n        [ACTIONS.enter]: STATES.entering,\n        [ACTIONS.setup]: () => {\n          const settings = node.control.getSettings();\n          if (node.parent) {\n            const parentSettings = node.parent.control.getSettings();\n            switch (node.parent.state) {\n              case STATES.entering:\n                {\n                  if (parentSettings.combine || settings.merge) {\n                    node.parent.manager.enterChildren([node]);\n                  }\n                  break;\n                }\n              // If the parent has already entered, enter the incoming children whether\n              // they have \"merge\" setting or the parent is in \"combine\" setting.\n              case STATES.entered:\n                {\n                  node.parent.manager.enterChildren([node]);\n                  break;\n                }\n            }\n          } else {\n            const isActive = settings.active === true || settings.active === undefined;\n            if (isActive) {\n              return STATES.entering;\n            }\n          }\n        }\n      }\n    },\n    [STATES.entering]: {\n      onEntry: {\n        execute: () => {\n          const {\n            combine\n          } = node.control.getSettings();\n          const children = combine ? Array.from(node.children) : Array.from(node.children).filter(child => child.control.getSettings().merge);\n          node.manager.enterChildren(children);\n        },\n        schedule: () => {\n          const {\n            duration\n          } = node.control.getSettings();\n          return {\n            duration: duration.delay + duration.enter || 0,\n            action: ACTIONS.enterEnd\n          };\n        }\n      },\n      onActions: {\n        [ACTIONS.enterEnd]: STATES.entered,\n        [ACTIONS.exit]: STATES.exiting,\n        [ACTIONS.refresh]: () => {\n          const settings = node.control.getSettings();\n          const childrenExited = Array.from(node.children).filter(child => child.state === STATES.exited);\n          if (settings.combine) {\n            node.manager.enterChildren(childrenExited);\n          } else {\n            const childrenMerged = childrenExited.filter(child => child.control.getSettings().merge);\n            node.manager.enterChildren(childrenMerged);\n          }\n        }\n      }\n    },\n    [STATES.entered]: {\n      onEntry: {\n        execute: () => {\n          const {\n            combine\n          } = node.control.getSettings();\n          if (combine) {\n            return;\n          }\n          const children = Array.from(node.children).filter(child => !child.control.getSettings().merge);\n          node.manager.enterChildren(children);\n        }\n      },\n      onActions: {\n        [ACTIONS.exit]: STATES.exiting,\n        [ACTIONS.refresh]: () => {\n          const childrenExited = Array.from(node.children).filter(child => child.state === STATES.exited);\n          node.manager.enterChildren(childrenExited);\n        }\n      }\n    },\n    [STATES.exiting]: {\n      onEntry: {\n        execute: () => {\n          Array.from(node.children).forEach(child => {\n            if (child.state === STATES.entering || child.state === STATES.entered) {\n              child.send(ACTIONS.exit);\n            } else if (child.state === STATES.exited) {\n              child.scheduler.stopAll();\n            }\n            // If the child is EXITING, it will go to EXITED soon.\n          });\n        },\n\n        schedule: () => ({\n          duration: node.control.getSettings().duration.exit || 0,\n          action: ACTIONS.exitEnd\n        })\n      },\n      onActions: {\n        [ACTIONS.exitEnd]: STATES.exited,\n        [ACTIONS.enter]: STATES.entering\n      }\n    },\n    '*': {\n      onActions: {\n        [ACTIONS.update]: () => {\n          var _a, _b;\n          const settings = node.control.getSettings();\n          if (settings.manager !== node.manager.name) {\n            (_b = (_a = node.manager).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n            node.manager = createAnimatorManager(node, settings.manager);\n          }\n          if (!node.parent) {\n            const isActive = settings.active === true || settings.active === undefined;\n            if ((state === STATES.exited || state === STATES.exiting) && isActive) {\n              return STATES.entering;\n            } else if ((state === STATES.entered || state === STATES.entering) && !isActive) {\n              return STATES.exiting;\n            }\n          }\n        }\n      }\n    }\n  };\n  const transition = newState => {\n    if (!newState || state === newState) {\n      return;\n    }\n    state = newState;\n    const {\n      onEntry\n    } = statesMap[state] || {};\n    const {\n      onTransition\n    } = node.control.getSettings();\n    node.scheduler.stopAll();\n    if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.execute) {\n      onEntry.execute();\n    }\n    if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.schedule) {\n      const task = onEntry.schedule();\n      node.scheduler.start(task.duration, () => send(task.action));\n    }\n    onTransition === null || onTransition === void 0 ? void 0 : onTransition(node);\n    for (const subscriber of node.subscribers) {\n      subscriber(node);\n    }\n  };\n  const processAction = procedure => {\n    if (procedure === undefined) {\n      return;\n    }\n    if (typeof procedure === 'string') {\n      transition(procedure);\n    } else {\n      const newState = procedure();\n      if (newState) {\n        transition(newState);\n      }\n    }\n  };\n  const getState = () => state;\n  const send = action => {\n    var _a, _b, _c, _d;\n    // In non-browser environments, there are no transitions.\n    if (!IS_BROWSER) {\n      return;\n    }\n    processAction((_b = (_a = statesMap[state]) === null || _a === void 0 ? void 0 : _a.onActions) === null || _b === void 0 ? void 0 : _b[action]);\n    processAction((_d = (_c = statesMap['*']) === null || _c === void 0 ? void 0 : _c.onActions) === null || _d === void 0 ? void 0 : _d[action]);\n  };\n  const machine = Object.freeze({\n    getState,\n    send\n  });\n  return machine;\n};\nexport { createAnimatorMachine };","map":{"version":3,"names":["IS_BROWSER","ANIMATOR_STATES","STATES","ANIMATOR_ACTIONS","ACTIONS","createAnimatorManager","createAnimatorMachine","node","initialState","state","statesMap","exited","onActions","enter","entering","setup","settings","control","getSettings","parent","parentSettings","combine","merge","manager","enterChildren","entered","isActive","active","undefined","onEntry","execute","children","Array","from","filter","child","schedule","duration","delay","action","enterEnd","exit","exiting","refresh","childrenExited","childrenMerged","forEach","send","scheduler","stopAll","exitEnd","update","_a","_b","name","destroy","call","transition","newState","onTransition","task","start","subscriber","subscribers","processAction","procedure","getState","_c","_d","machine","Object","freeze"],"sources":["/Users/richardbrown/Desktop/react example/my-app/node_modules/@arwes/animator/build/esm/internal/createAnimatorMachine/createAnimatorMachine.js"],"sourcesContent":["import { IS_BROWSER } from '@arwes/tools';\nimport { ANIMATOR_STATES as STATES, ANIMATOR_ACTIONS as ACTIONS } from \"../../constants.js\";\nimport { createAnimatorManager } from \"../../internal/createAnimatorManager/index.js\";\nconst createAnimatorMachine = (node, initialState) => {\n    let state = initialState;\n    const statesMap = {\n        [STATES.exited]: {\n            onActions: {\n                [ACTIONS.enter]: STATES.entering,\n                [ACTIONS.setup]: () => {\n                    const settings = node.control.getSettings();\n                    if (node.parent) {\n                        const parentSettings = node.parent.control.getSettings();\n                        switch (node.parent.state) {\n                            case STATES.entering: {\n                                if (parentSettings.combine || settings.merge) {\n                                    node.parent.manager.enterChildren([node]);\n                                }\n                                break;\n                            }\n                            // If the parent has already entered, enter the incoming children whether\n                            // they have \"merge\" setting or the parent is in \"combine\" setting.\n                            case STATES.entered: {\n                                node.parent.manager.enterChildren([node]);\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        const isActive = settings.active === true ||\n                            settings.active === undefined;\n                        if (isActive) {\n                            return STATES.entering;\n                        }\n                    }\n                }\n            }\n        },\n        [STATES.entering]: {\n            onEntry: {\n                execute: () => {\n                    const { combine } = node.control.getSettings();\n                    const children = combine\n                        ? Array.from(node.children)\n                        : Array.from(node.children).filter(child => child.control.getSettings().merge);\n                    node.manager.enterChildren(children);\n                },\n                schedule: () => {\n                    const { duration } = node.control.getSettings();\n                    return {\n                        duration: (duration.delay + duration.enter) || 0,\n                        action: ACTIONS.enterEnd\n                    };\n                }\n            },\n            onActions: {\n                [ACTIONS.enterEnd]: STATES.entered,\n                [ACTIONS.exit]: STATES.exiting,\n                [ACTIONS.refresh]: () => {\n                    const settings = node.control.getSettings();\n                    const childrenExited = Array\n                        .from(node.children)\n                        .filter(child => child.state === STATES.exited);\n                    if (settings.combine) {\n                        node.manager.enterChildren(childrenExited);\n                    }\n                    else {\n                        const childrenMerged = childrenExited\n                            .filter(child => child.control.getSettings().merge);\n                        node.manager.enterChildren(childrenMerged);\n                    }\n                }\n            }\n        },\n        [STATES.entered]: {\n            onEntry: {\n                execute: () => {\n                    const { combine } = node.control.getSettings();\n                    if (combine) {\n                        return;\n                    }\n                    const children = Array\n                        .from(node.children)\n                        .filter(child => !child.control.getSettings().merge);\n                    node.manager.enterChildren(children);\n                }\n            },\n            onActions: {\n                [ACTIONS.exit]: STATES.exiting,\n                [ACTIONS.refresh]: () => {\n                    const childrenExited = Array\n                        .from(node.children)\n                        .filter(child => child.state === STATES.exited);\n                    node.manager.enterChildren(childrenExited);\n                }\n            }\n        },\n        [STATES.exiting]: {\n            onEntry: {\n                execute: () => {\n                    Array.from(node.children).forEach(child => {\n                        if (child.state === STATES.entering || child.state === STATES.entered) {\n                            child.send(ACTIONS.exit);\n                        }\n                        else if (child.state === STATES.exited) {\n                            child.scheduler.stopAll();\n                        }\n                        // If the child is EXITING, it will go to EXITED soon.\n                    });\n                },\n                schedule: () => ({\n                    duration: node.control.getSettings().duration.exit || 0,\n                    action: ACTIONS.exitEnd\n                })\n            },\n            onActions: {\n                [ACTIONS.exitEnd]: STATES.exited,\n                [ACTIONS.enter]: STATES.entering\n            }\n        },\n        '*': {\n            onActions: {\n                [ACTIONS.update]: () => {\n                    var _a, _b;\n                    const settings = node.control.getSettings();\n                    if (settings.manager !== node.manager.name) {\n                        (_b = (_a = node.manager).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n                        node.manager = createAnimatorManager(node, settings.manager);\n                    }\n                    if (!node.parent) {\n                        const isActive = settings.active === true ||\n                            settings.active === undefined;\n                        if ((state === STATES.exited || state === STATES.exiting) && isActive) {\n                            return STATES.entering;\n                        }\n                        else if ((state === STATES.entered || state === STATES.entering) && !isActive) {\n                            return STATES.exiting;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    const transition = (newState) => {\n        if (!newState || state === newState) {\n            return;\n        }\n        state = newState;\n        const { onEntry } = statesMap[state] || {};\n        const { onTransition } = node.control.getSettings();\n        node.scheduler.stopAll();\n        if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.execute) {\n            onEntry.execute();\n        }\n        if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.schedule) {\n            const task = onEntry.schedule();\n            node.scheduler.start(task.duration, () => send(task.action));\n        }\n        onTransition === null || onTransition === void 0 ? void 0 : onTransition(node);\n        for (const subscriber of node.subscribers) {\n            subscriber(node);\n        }\n    };\n    const processAction = (procedure) => {\n        if (procedure === undefined) {\n            return;\n        }\n        if (typeof procedure === 'string') {\n            transition(procedure);\n        }\n        else {\n            const newState = procedure();\n            if (newState) {\n                transition(newState);\n            }\n        }\n    };\n    const getState = () => state;\n    const send = (action) => {\n        var _a, _b, _c, _d;\n        // In non-browser environments, there are no transitions.\n        if (!IS_BROWSER) {\n            return;\n        }\n        processAction((_b = (_a = statesMap[state]) === null || _a === void 0 ? void 0 : _a.onActions) === null || _b === void 0 ? void 0 : _b[action]);\n        processAction((_d = (_c = statesMap['*']) === null || _c === void 0 ? void 0 : _c.onActions) === null || _d === void 0 ? void 0 : _d[action]);\n    };\n    const machine = Object.freeze({ getState, send });\n    return machine;\n};\nexport { createAnimatorMachine };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}