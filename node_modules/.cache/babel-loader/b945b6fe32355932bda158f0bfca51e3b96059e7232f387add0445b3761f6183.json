{"ast":null,"code":"import React, { useRef, useEffect } from 'react';\nimport { animate } from 'motion';\nimport { cx, randomizeList } from '@arwes/tools';\nimport { mergeRefs } from '@arwes/react-tools';\nimport { easing } from '@arwes/animated';\nimport { ANIMATOR_STATES } from '@arwes/animator';\nimport { useAnimator } from '@arwes/react-animator';\nconst {\n  entering,\n  exiting,\n  exited\n} = ANIMATOR_STATES;\nconst random = (min, max) => (max - min) * Math.random();\nconst minmaxOverflow01 = value => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));\n// Create a list of lines in the given available canvas axis size.\n// The lines are placed at random positions in the grid.\nconst createLinesSet = config => {\n  const {\n    distance,\n    positionsLength,\n    margin,\n    size\n  } = config;\n  const linesLength = Math.floor(random(0.1, 0.5) * positionsLength);\n  const positions = Array(positionsLength).fill(0).map((_, i) => i);\n  const positionsRandom = randomizeList(positions);\n  const positionsSelected = positionsRandom.slice(0, linesLength);\n  return positionsSelected.map(position => {\n    const axis1 = margin / 2 + position * distance;\n    const axis2Initial = Math.random() * (size / 2);\n    const length = Math.floor(random(0.1, 0.5) * size);\n    return {\n      axis1,\n      axis2Initial,\n      length\n    };\n  });\n};\nconst defaultProps = {\n  lineWidth: 1,\n  lineColor: '#777',\n  distance: 30,\n  sets: 5\n};\nconst MovingLines = props => {\n  const propsFull = {\n    ...defaultProps,\n    ...props\n  };\n  const {\n    elementRef: elementRefExternal,\n    className,\n    style\n  } = propsFull;\n  const animator = useAnimator();\n  const elementRef = useRef(null);\n  const propsFullRef = useRef(propsFull);\n  propsFullRef.current = propsFull;\n  useEffect(() => {\n    if (!animator) {\n      return;\n    }\n    const canvas = elementRef.current;\n    const ctx = canvas.getContext('2d');\n    let transitionControl;\n    let intervalControl;\n    let linesSets = [];\n    const draw = intervalProgress => {\n      const {\n        lineWidth,\n        lineColor,\n        distance,\n        sets: linesSetsLength\n      } = propsFullRef.current;\n      const width = canvas.clientWidth;\n      const height = canvas.clientHeight;\n      const isResized = canvas.width !== width || canvas.height !== height;\n      const axis1Size = width;\n      const axis2Size = height;\n      const positionsLength = 1 + Math.floor(axis1Size / distance);\n      const margin = axis1Size % distance;\n      canvas.width = width;\n      canvas.height = height;\n      ctx.clearRect(0, 0, width, height);\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = lineColor;\n      ctx.shadowBlur = lineWidth;\n      ctx.shadowOffsetX = 0;\n      ctx.shadowOffsetY = 0;\n      ctx.shadowColor = lineColor;\n      if (linesSets.length === 0 || isResized) {\n        linesSets = Array(linesSetsLength).fill(null).map(() => createLinesSet({\n          positionsLength,\n          margin,\n          distance,\n          size: axis2Size\n        }));\n      }\n      linesSets.forEach((linesSet, linesSetIndex) => {\n        // \"intervalProgress\" goes from 0 to 1 repeatedly indicating each interval.\n        // Every set of lines will have an progress offset so the its animation\n        // starts/ends at different times than each other.\n        // Since those sets will start later in time, they will end faster, so\n        // when they do, they extra progress offset will start from the beginning.\n        // So if one set ends at 1.23 in the animation progress, it overflows\n        // and becomes 0.23.\n        const linesSetProgressOffset = 1 / linesSetsLength * linesSetIndex;\n        const progress = minmaxOverflow01(intervalProgress + linesSetProgressOffset);\n        const progressEase = easing.inOutCubic(progress);\n        linesSet.forEach(line => {\n          const {\n            axis1,\n            axis2Initial,\n            length\n          } = line;\n          // Move the line from before to after the visible space.\n          const axis2Move = axis2Size * 2 * progressEase - axis2Size;\n          ctx.beginPath();\n          ctx.moveTo(axis1, axis2Size - (axis2Initial + axis2Move));\n          ctx.lineTo(axis1, axis2Size - (axis2Initial + length + axis2Move));\n          ctx.stroke();\n          ctx.closePath();\n        });\n      });\n    };\n    const animatorSubscription = node => {\n      const state = node.state;\n      const {\n        duration\n      } = node.control.getSettings();\n      switch (state) {\n        case entering:\n          {\n            transitionControl = animate(canvas, {\n              opacity: [0, 1]\n            }, {\n              duration: duration === null || duration === void 0 ? void 0 : duration.enter,\n              easing: 'ease-out'\n            });\n            intervalControl = animate(draw, {\n              duration: duration === null || duration === void 0 ? void 0 : duration.interval,\n              easing: 'linear',\n              repeat: Infinity\n            });\n            break;\n          }\n        case exiting:\n          {\n            transitionControl = animate(canvas, {\n              opacity: [1, 0]\n            }, {\n              duration: duration === null || duration === void 0 ? void 0 : duration.exit,\n              easing: 'ease-out'\n            });\n            break;\n          }\n        case exited:\n          {\n            intervalControl === null || intervalControl === void 0 ? void 0 : intervalControl.cancel();\n            break;\n          }\n      }\n    };\n    animator.node.subscribers.add(animatorSubscription);\n    return () => {\n      animator.node.subscribers.delete(animatorSubscription);\n      transitionControl === null || transitionControl === void 0 ? void 0 : transitionControl.cancel();\n      intervalControl === null || intervalControl === void 0 ? void 0 : intervalControl.cancel();\n    };\n  }, [animator]);\n  return React.createElement(\"canvas\", {\n    ref: mergeRefs(elementRef, elementRefExternal),\n    className: cx('arwes-react-bgs-movinglines', className),\n    style: {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      display: 'block',\n      border: 0,\n      margin: 0,\n      padding: 0,\n      width: '100%',\n      height: '100%',\n      opacity: 0,\n      ...style\n    }\n  });\n};\nMovingLines.defaultProps = defaultProps;\nexport { MovingLines };","map":{"version":3,"names":["React","useRef","useEffect","animate","cx","randomizeList","mergeRefs","easing","ANIMATOR_STATES","useAnimator","entering","exiting","exited","random","min","max","Math","minmaxOverflow01","value","createLinesSet","config","distance","positionsLength","margin","size","linesLength","floor","positions","Array","fill","map","_","i","positionsRandom","positionsSelected","slice","position","axis1","axis2Initial","length","defaultProps","lineWidth","lineColor","sets","MovingLines","props","propsFull","elementRef","elementRefExternal","className","style","animator","propsFullRef","current","canvas","ctx","getContext","transitionControl","intervalControl","linesSets","draw","intervalProgress","linesSetsLength","width","clientWidth","height","clientHeight","isResized","axis1Size","axis2Size","clearRect","strokeStyle","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","forEach","linesSet","linesSetIndex","linesSetProgressOffset","progress","progressEase","inOutCubic","line","axis2Move","beginPath","moveTo","lineTo","stroke","closePath","animatorSubscription","node","state","duration","control","getSettings","opacity","enter","interval","repeat","Infinity","exit","cancel","subscribers","add","delete","createElement","ref","left","top","display","border","padding"],"sources":["/Users/richardbrown/Desktop/react example/my-app/node_modules/@arwes/react-bgs/build/esm/MovingLines/MovingLines.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { animate } from 'motion';\nimport { cx, randomizeList } from '@arwes/tools';\nimport { mergeRefs } from '@arwes/react-tools';\nimport { easing } from '@arwes/animated';\nimport { ANIMATOR_STATES } from '@arwes/animator';\nimport { useAnimator } from '@arwes/react-animator';\nconst { entering, exiting, exited } = ANIMATOR_STATES;\nconst random = (min, max) => (max - min) * Math.random();\nconst minmaxOverflow01 = (value) => Math.min(1, Math.max(0, value === 1 ? 1 : value % 1));\n// Create a list of lines in the given available canvas axis size.\n// The lines are placed at random positions in the grid.\nconst createLinesSet = (config) => {\n    const { distance, positionsLength, margin, size } = config;\n    const linesLength = Math.floor(random(0.1, 0.5) * positionsLength);\n    const positions = Array(positionsLength).fill(0).map((_, i) => i);\n    const positionsRandom = randomizeList(positions);\n    const positionsSelected = positionsRandom.slice(0, linesLength);\n    return positionsSelected.map(position => {\n        const axis1 = (margin / 2) + (position * distance);\n        const axis2Initial = Math.random() * (size / 2);\n        const length = Math.floor(random(0.1, 0.5) * size);\n        return { axis1, axis2Initial, length };\n    });\n};\nconst defaultProps = {\n    lineWidth: 1,\n    lineColor: '#777',\n    distance: 30,\n    sets: 5\n};\nconst MovingLines = (props) => {\n    const propsFull = { ...defaultProps, ...props };\n    const { elementRef: elementRefExternal, className, style } = propsFull;\n    const animator = useAnimator();\n    const elementRef = useRef(null);\n    const propsFullRef = useRef(propsFull);\n    propsFullRef.current = propsFull;\n    useEffect(() => {\n        if (!animator) {\n            return;\n        }\n        const canvas = elementRef.current;\n        const ctx = canvas.getContext('2d');\n        let transitionControl;\n        let intervalControl;\n        let linesSets = [];\n        const draw = (intervalProgress) => {\n            const { lineWidth, lineColor, distance, sets: linesSetsLength } = propsFullRef.current;\n            const width = canvas.clientWidth;\n            const height = canvas.clientHeight;\n            const isResized = canvas.width !== width || canvas.height !== height;\n            const axis1Size = width;\n            const axis2Size = height;\n            const positionsLength = 1 + Math.floor(axis1Size / distance);\n            const margin = axis1Size % distance;\n            canvas.width = width;\n            canvas.height = height;\n            ctx.clearRect(0, 0, width, height);\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = lineColor;\n            ctx.shadowBlur = lineWidth;\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n            ctx.shadowColor = lineColor;\n            if (linesSets.length === 0 || isResized) {\n                linesSets = Array(linesSetsLength).fill(null).map(() => createLinesSet({ positionsLength, margin, distance, size: axis2Size }));\n            }\n            linesSets.forEach((linesSet, linesSetIndex) => {\n                // \"intervalProgress\" goes from 0 to 1 repeatedly indicating each interval.\n                // Every set of lines will have an progress offset so the its animation\n                // starts/ends at different times than each other.\n                // Since those sets will start later in time, they will end faster, so\n                // when they do, they extra progress offset will start from the beginning.\n                // So if one set ends at 1.23 in the animation progress, it overflows\n                // and becomes 0.23.\n                const linesSetProgressOffset = ((1 / linesSetsLength) * linesSetIndex);\n                const progress = minmaxOverflow01(intervalProgress + linesSetProgressOffset);\n                const progressEase = easing.inOutCubic(progress);\n                linesSet.forEach(line => {\n                    const { axis1, axis2Initial, length } = line;\n                    // Move the line from before to after the visible space.\n                    const axis2Move = ((axis2Size * 2) * progressEase) - axis2Size;\n                    ctx.beginPath();\n                    ctx.moveTo(axis1, axis2Size - (axis2Initial + axis2Move));\n                    ctx.lineTo(axis1, axis2Size - (axis2Initial + length + axis2Move));\n                    ctx.stroke();\n                    ctx.closePath();\n                });\n            });\n        };\n        const animatorSubscription = (node) => {\n            const state = node.state;\n            const { duration } = node.control.getSettings();\n            switch (state) {\n                case entering: {\n                    transitionControl = animate(canvas, { opacity: [0, 1] }, { duration: duration === null || duration === void 0 ? void 0 : duration.enter, easing: 'ease-out' });\n                    intervalControl = animate(draw, { duration: duration === null || duration === void 0 ? void 0 : duration.interval, easing: 'linear', repeat: Infinity });\n                    break;\n                }\n                case exiting: {\n                    transitionControl = animate(canvas, { opacity: [1, 0] }, { duration: duration === null || duration === void 0 ? void 0 : duration.exit, easing: 'ease-out' });\n                    break;\n                }\n                case exited: {\n                    intervalControl === null || intervalControl === void 0 ? void 0 : intervalControl.cancel();\n                    break;\n                }\n            }\n        };\n        animator.node.subscribers.add(animatorSubscription);\n        return () => {\n            animator.node.subscribers.delete(animatorSubscription);\n            transitionControl === null || transitionControl === void 0 ? void 0 : transitionControl.cancel();\n            intervalControl === null || intervalControl === void 0 ? void 0 : intervalControl.cancel();\n        };\n    }, [animator]);\n    return (React.createElement(\"canvas\", { ref: mergeRefs(elementRef, elementRefExternal), className: cx('arwes-react-bgs-movinglines', className), style: {\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            display: 'block',\n            border: 0,\n            margin: 0,\n            padding: 0,\n            width: '100%',\n            height: '100%',\n            opacity: 0,\n            ...style\n        } }));\n};\nMovingLines.defaultProps = defaultProps;\nexport { MovingLines };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}